#!/bin/env python3
# -----------------------------------------------------------------------------------------
# leonard heywang <leonard.heywang@proton.me>
# 03-01-2026
#
# This tool parse json (from verilator), and look for the ports. Then, it'll
# generate a top level file, which just combine them.
# -----------------------------------------------------------------------------------------
import argparse
from pathlib import Path
import datetime
from dataclasses import dataclass

from pyverilog.vparser.parser import parse
from pyverilog.vparser.ast import ModuleDef, Width
from pyverilog.vparser.ast import Input as astInput
from pyverilog.vparser.ast import Output as astOutput
from pyverilog.vparser.ast import Inout as astInout


@dataclass(frozen=True)
class dataport:
    name: str
    direction: str
    type: str
    width: str


def va2v(input: Path, output: Path) -> None:
    """
    This small function generate a verilog stub from a VerilogA file.
    This, indeed does not account for the functionnality, it's only to make possible to Verilog to count the ports on it.
    """
    data = None

    # First, fetch data as a single line (enable splits) :
    with open(input, "r") as f:
        data = f.read().strip().replace("\n", "#")

    # Split to known keywords that are mandatory :
    data = data.split("module")[1].split("analog")[0].strip()

    # Restore newlines
    data = data.replace("#", "\n").split("\n")

    # Remove unwanted lines :
    for line in data:
        if "electrical" in line:
            data.remove(line)

    # Finally, write the new file :
    with open(output, "w+") as f:
        f.write(f"// THIS FILE WAS AUTOGENERATED. DO NOT EDIT.\n")
        f.write(f"// ORIGINAL FILE WAS : {str(input)}\n\n")

        f.write("module ")

        for line in data:
            if len(line.strip()) > 1:
                f.write(f"{line.strip()}\n")

        f.write("endmodule\n\n")
        f.write(f"// FILE WAS CREATED ON :{datetime.datetime.now()}\n\n")

    return


def parse_file(
    files: list[Path],
) -> tuple[list[dataport], list[dataport], list[dataport]]:
    """
    This function count the port, and resolve their specs into the generated JSON.
    """

    # Init ports
    ins = []
    outs = []
    inouts = []
    modules = []

    for file in files:
        print(f"Parsing file : {str(file)} ...")
        ast, directives = parse([f"{str(file)}"])

        for item in ast.description.definitions:
            if not isinstance(item, ModuleDef):
                continue

            for port in item.portlist.ports:
                elems = port.children()

                for elem in elems:
                    if isinstance(elem, (astInput, astOutput, astInout)):

                        width = "0:0"
                        if isinstance(elem.width, Width):
                            width = f"{elem.width.msb}:{elem.width.lsb}"

                        if isinstance(elem, astInput):
                            ins.append(
                                dataport(
                                    f"{item.name}#{elem.name}",
                                    "INPUT",
                                    "NONE",
                                    str(width),
                                )
                            )
                        elif isinstance(elem, astOutput):
                            outs.append(
                                dataport(
                                    f"{item.name}#{elem.name}",
                                    "OUTPUT",
                                    "NONE",
                                    str(width),
                                )
                            )
                        elif isinstance(elem, astInout):
                            inouts.append(
                                dataport(
                                    f"{item.name}#{elem.name}",
                                    "INOUT",
                                    "NONE",
                                    str(width),
                                )
                            )

            modules.append(f"{item.name}")

    return ins, outs, inouts, modules


def match_ports(
    inputs: list[dataport], outputs: list[dataport], inouts: list[dataport]
) -> tuple[list[dataport], list[dataport], list[dataport], list[dataport]]:
    """
    This function look for duplicate net names, and transform them into wires to be shared rather than individual ports.
    """
    wires = []
    internals = []

    def get_wires(
        ports_in: list[dataport], ports_out: list[dataport]
    ) -> list[dataport]:
        t_wires = []

        # That's not really nice in terms of performance O(n2), but as they're top modules, we don't expect very long lists, the delta is acceptable.
        for port1 in ports_in:
            for port2 in ports_out:
                if port1 is port2:
                    continue

                if port1.name.split("#")[-1] == port2.name.split("#")[-1]:
                    t_wires.append(
                        dataport(
                            port1.name.split("#")[-1],
                            port1.direction,
                            port1.type,
                            port1.width,
                        )
                    )

        return t_wires

    # end of function

    # Matching the ports within them :
    wires.extend(get_wires(inputs, inputs))
    wires.extend(get_wires(outputs, outputs))
    wires.extend(get_wires(inouts, inouts))

    # Matching port that are output to inputs
    internals.extend(get_wires(outputs, inputs))

    # Removing duplicates
    wires = list(set(wires))

    return inputs, outputs, inouts, wires, internals


def generate_module(
    target: Path,
    modules: list[str],
    inputs: list[dataport],
    outputs: list[dataport],
    inouts: list[dataport],
    wires: list[dataport],
    internals: list[dataport],
) -> None:
    """
    Generate the top level verilog file, that will be compiled into the ngspice shared library
    """

    with open(target, "w+") as f:
        # Adding some basic verilog features
        f.write(f"// =========================================\n")
        f.write(f"// THIS FILE WAS AUTOGENERATED. DO NOT EDIT.\n")
        f.write(f"// =========================================\n\n")

        f.write(f"module {target.stem} (\n")

        first = False

        # Generating a global net list and add them to the module
        globnet = []
        for wire in wires:
            globnet.append(wire.name)
            # Add the comma if needed :
            if first != False:
                f.write(",")
            f.write(
                f"\n    {wire.direction.lower():8} [{str(wire.width).center(8)}] {wire.name.replace("#", "_")}"
            )
            first = True

        # Generating a wire net list and add them to the module
        internet = []
        for wire in internals:
            internet.append(wire.name)

        def append_nets(netlist: list[dataport], type: str, first: bool):
            # Iterate over the nets :
            for net in netlist:

                # Ensure the net is not global
                if (net.name.split("#")[-1] not in globnet) and (
                    net.name.split("#")[-1] not in internet
                ):

                    # Add the comma if needed :
                    if first != False:
                        f.write(",")

                    # Write the net and update the first
                    f.write(
                        f"\n    {type:8} [{str(net.width).center(8)}] {net.name.replace("#", "_")}"
                    )
                    first = True

        # Adding unique ports :
        append_nets(inouts, "inout", first)
        append_nets(inputs, "input", first)
        append_nets(outputs, "output", first)

        # Closing module init :
        f.write("\n\n);\n")

        # Adding the wires :
        for wire in internals:
            f.write(
                f"\n    wire [{str(wire.width).center(8)}] {wire.name.replace("#", "_")};"
            )
        f.write("\n\n")

        def append_module_net(
            netlist: list[dataport], file, module_name, first
        ) -> bool:

            # Iterate over the nets lists :
            for net in netlist:

                # If the net is from within this module :
                if net.name.split("#")[0] == module_name:

                    # Append comma if needed
                    if first != False:
                        file.write(",")

                    # Write the verilog syntax to connect it
                    if (net.name.split("#")[-1] in globnet) or (
                        net.name.split("#")[-1] in internet
                    ):
                        file.write(
                            f"\n        .{str(net.name.split("#")[-1]):12}({net.name.split("#")[-1]})"
                        )
                    else:
                        file.write(
                            f"\n        .{str(net.name.split("#")[-1]):12}({net.name.replace("#", "_")})"
                        )
                    first = True

            return first

        # Adding component instantiation now :
        for module in modules:
            f.write(f"    {module} u_{module} (")

            # Append the net names
            first = False
            first = append_module_net(inouts, f, module, first)
            first = append_module_net(inputs, f, module, first)
            first = append_module_net(outputs, f, module, first)

            f.write("\n    );\n\n")

            # Need to handle the missing pins -> mis_matched naming !

        f.write("endmodule\n\n")

        f.write(f"// ===============================================\n")
        f.write(f"// FILE WAS CREATED ON :{datetime.datetime.now()}\n")
        f.write(f"// ===============================================\n")

    return


def generate_analog_spice_string():
    return ""


def generate_digital_spice_string():
    return ""


def generate_sym(
    target: Path,
    analog: bool,
    inputs: list[dataport],
    outputs: list[dataport],
    inouts: list[dataport],
    wires: list[dataport],
    internals: list[dataport],
    include: Path
) -> None:

    # Define space between pins :
    PITCH = 20

    # Define the offsets from the sides :
    OFFSET = PITCH / 2

    # Defie the size of a pad :
    PIN_SIZE = 5

    # Define the offset of a text to it's pad
    TEXT_OFFSET_X = 5
    TEXT_OFFSET_Y = 4
    TEXT_CHAR_SIZE = 2.75

    # Handling the removal of the already_handled nets :
    removals = [net.name for net in internals]
    globnets = [net.name for net in wires]

    removals.extend(globnets)
    removed = []

    def remove_pins(ports: list[dataport]) -> list[dataport]:
        retlist = []
        for port in ports:
            if port.name.split("#")[-1] not in removals:
                retlist.append(port)
            else:
                if port.name.split("#")[-1] not in removed:
                    removed.append(port)
        return retlist

    # Remove global pins (duplicates, to let the symbol simpler : )
    i_inputs = remove_pins(inputs)
    i_outputs = remove_pins(outputs)
    i_inouts = remove_pins(inouts)

    # Finally, append the globnets
    for globnet in wires:
        match globnet.direction:
            case "INPUT":
                i_inputs.insert(0, globnet)
            case "OUTPUT":
                i_outputs.insert(0, globnet)
            case "INOUT":
                i_inouts.insert(0, globnet)

    with open(target, "w+") as f:

        # Append the basic elements of the file :
        f.write("v {xschem version=3.4.4 file_version=1.2}\n")
        f.write("* This file was autogenerated by the genwrapper script.\n")
        f.write("* Please do not edit it by hand.\n")

        # Append some data :
        f.write("K {}\n")
        f.write("V {}\n")
        f.write("S {}\n")
        f.write("E {}\n\n")

        # Get sizes of the symbol box :
        def get_dimension(size: int) -> int:
            return ((size - 1) * PITCH) + (2 * OFFSET)

        # Then, call the functions and determine the size matrix (with a minimum to 40 to ensure a visible symbol)
        height = max(get_dimension(len(i_inputs)), get_dimension(len(i_outputs)), 80.0)
        width = max(get_dimension(len(i_inouts)), 80.0)

        # Define some extrems :
        x_left = -(width / 2)
        x_right = width / 2
        y_top = -(height / 2)
        y_bot = height / 2

        coordinates = [
            [x_left, y_bot, x_left, y_top],
            [x_left, y_top, x_right, y_top],
            [x_right, y_top, x_right, y_bot],
            [x_right, y_bot, x_left, y_bot],
        ]

        # Draw the box on the symbol :
        for coordinate in coordinates:
            f.write(
                f"L 4 {coordinate[0]} {coordinate[1]} {coordinate[2]} {coordinate[3]} {"{}"}\n"
            )
        f.write("\n")

        # Then, create the coordinates for the pins :
        def get_pins_position(
            orig: int, fixed: int, number: int
        ) -> list[list[int, int]]:
            pins = []
            act_pos = orig + OFFSET

            for _ in range(number):
                pins.append([fixed, act_pos])
                act_pos += PITCH

            return pins

        in_pins = get_pins_position(y_top, x_left, len(i_inputs))
        out_pins = get_pins_position(y_top, x_right, len(i_outputs))
        io_pins = get_pins_position(x_left, y_bot, len(i_inouts))

        # Then, place the pins on the file :
        def place_pins(
            pins: list[list[int, int]],
            pin_data: list[dataport],
            direction: str,
            pins_cnt,
            file,
        ) -> None:
            for index, pin in enumerate(pins):
                extrems = [
                    [pin[0] - (PIN_SIZE / 2), pin[1] - (PIN_SIZE / 2)],
                    [pin[0] + (PIN_SIZE / 2), pin[1] + (PIN_SIZE / 2)],
                ]
                file.write(
                    f"B 5 {extrems[0][0]} {extrems[0][1]} {extrems[1][0]} {extrems[1][1]} {"{"}{f"name={pin_data[index].name.replace("#", "_")} dir={direction} seq={pins_cnt}"}{"}"}\n"
                )
                # Place the text near the pad :
                x_pos = (
                    (pin[0] + TEXT_OFFSET_X)
                    if pin[0] < 0
                    else (
                        pin[0]
                        - TEXT_OFFSET_X
                        - (TEXT_CHAR_SIZE * len(pin_data[index].name))
                    )
                )
                file.write(
                    f"T {"{"}{pin_data[index].name.replace("#", "_")}{"}"} {x_pos} {pin[1] - TEXT_OFFSET_Y} 0 0.1 0.1 {"{}"}\n"
                )
                pins_cnt += 1
            return pins_cnt

        # We add a variable to track the seq id
        pins_cnt = 0
        pins_cnt = place_pins(in_pins, i_inputs, "in", pins_cnt, f)
        pins_cnt = place_pins(out_pins, i_outputs, "out", pins_cnt, f)
        pins_cnt = place_pins(io_pins, i_inouts, "inout", pins_cnt, f)
        f.write("\n")

        # Add entity name and module :
        name = str(target.name).split(".")[0]
        f.write(
            f"T {"{"}{name}{"}"} {0 - (TEXT_CHAR_SIZE * len(name))} {0 - (TEXT_CHAR_SIZE * len(name))} 0 0 0.2 0.2\n"
        )
        f.write(f"T {"{"}@name{"}"} 0 -10 0 0 0.2 0.2\n")

        # Add the spice string :
        spice_string = ""
        if analog == True:
            spice_string = generate_analog_spice_string()
        else:
            spice_string = generate_digital_spice_string()

        print(include)

        # Finally, append the spice attributes to the model :
        f.write("\n")
        f.write(f"G {"{"}type=subcircuit \n")
        f.write('format="@name @pinlist @model"\n')
        f.write(f'template="name=X1 model={str(target.name).split(".")[0]}"\n')
        f.write(f'spice_sym_def="{spice_string}"\n')
        f.write("}\n\n")
        f.write("* END OF THE SYMBOL\n")

    return


if __name__ == "__main__":
    parser = argparse.ArgumentParser()
    parser.add_argument(
        "files",
        nargs="+",
        help="The input verilog files to be combined into a single top",
    )
    parser.add_argument(
        "-n",
        "--name",
        default="top.v",
        help="Name of the top module to be used. Default = top.v",
    )
    parser.add_argument(
        "-t",
        "--temp",
        default="/tmp/wrappergen",
        help="Path of the temporary json files. Default to /tmp/wrappengen/",
    )
    parser.add_argument(
        "-m",
        "--merge_wires",
        default="yes",
        help="Automatically merge the wire that share a same net into a single output at the end. Default = yes.",
    )
    parser.add_argument(
        "-s",
        "--sym",
        default="yes",
        help="Generate the xschem symbol in the same pass. Default = yes",
    )
    parser.add_argument(
        "-a",
        "--analog",
        default="no",
        help="Enable the analog mode, in which the file is treated as it, and generate a symbol from it. Default to no.",
    )
    parser.add_argument(
        "-v",
        "--voltage",
        default="3.3",
        help='Enable to configure the voltage level used for the ADC / DAC bridges on digital blocks. Ignored for analog blocks. Default to "3.3" (V)',
    )
    parser.add_argument(
        "-va",
        "--veriloga-file",
        default="top.osdi",
        help="Set the name of the OSDI file that must be used. Default to the same name as the veriloga file, with the extension renamed to .osdi.\nThis option is only used in analog mode."
    )

    parser.description = """This tool enable the user to combine multiple verilog files into a single, higher level one.
    especially usefull when working with d_cosim in ngspice, which can only tolerate a single digital block !"""

    parser.epilog = """If you have some issues, perhaps use the -m=no / --merge_wires=no option to disable the grouping of the same 
    net ports. With the default value, two ports that share the name "clk" would be exposed as one. This make the design simpler,
    but could lead to issues. Always start here ! If none of the solution works, you still could write your own top, and let the script only generate the symbol for you !"""

    # Parse arguments :
    args = parser.parse_args()

    # First, ensure path are existing :
    tmp = Path(args.temp)
    tmp.mkdir(parents=True, exist_ok=True)

    # Ensure no more than one file in analog mode was passed :
    if args.analog == "yes":
        if len(args.files) > 1:
            print("In analog mode, no more than one file are handled.")
            exit(1)

    # Generate paths and files lists
    sources = [Path(t).resolve() for t in args.files]
    extracted = [Path(tmp / t.name).with_suffix(".json") for t in sources]
    top = Path(args.name).resolve()
    sym = top.with_suffix(".sym")
    include = None

    # If we're in analog mode : Convert the file into it's digital stub
    if args.analog == "yes":
        print("Converting the .va file into it's verilog stub ...")
        sources = sources[0]
        include = sources.with_suffix(".osdi")
        vlog = extracted[0].with_suffix(".v")
        va2v(sources, vlog)
        sources = [vlog]

    # Generate the JSON data and extract the data
    print("Parsing files ...")
    inputs, outputs, inouts, modules = parse_file(sources)

    # Optionnaly, match the ports :
    wires = []
    internals = []
    if args.merge_wires == "yes":
        print("Combining ports into single ports ...")
        inputs, outputs, inouts, wires, internals = match_ports(inputs, outputs, inouts)

    # If needed, generating the top level entity :
    if args.analog == "no":
        print("Generating verilog top module ...")
        generate_module(top, modules, inputs, outputs, inouts, wires, internals)

    # Generating the symbol file:
    if args.analog == "yes":
        print("Generating analog symbol ...")
        generate_sym(sym, True, inputs, outputs, inouts, wires, internals, include)
    else:
        print("Generating digital symbol ...")
        generate_sym(sym, False, inputs, outputs, inouts, wires, internals, include)

    # Finish and exit :
    print("Finished")
