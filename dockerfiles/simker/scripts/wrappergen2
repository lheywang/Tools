#!/bin/env python3
# -----------------------------------------------------------------------------------------
# leonard heywang <leonard.heywang@proton.me>
# 03-01-2026
#
# This tool parse json (from verilator), and look for the ports. Then, it'll
# generate a top level file, which just combine them.
# -----------------------------------------------------------------------------------------
import json
import argparse
from pathlib import Path
import subprocess
import datetime
from dataclasses import dataclass


@dataclass(frozen=True)
class dataport:
    name: str
    direction: str
    type: str
    width: int


def va2v(input: Path, output: Path) -> None:
    """
    This small function generate a verilog stub from a VerilogA file.
    This, indeed does not account for the functionnality, it's only to make possible to Verilog to count the ports on it.
    """
    data = None

    # First, fetch data as a single line (enable splits) :
    with open(input, "r") as f:
        data = f.read().strip().replace("\n", "#")

    # Split to known keywords that are mandatory :
    data = data.split("module")[1].split("analog")[0].strip()

    # Restore newlines
    data = data.replace("#", "\n").split("\n")

    # Remove unwanted lines :
    for line in data:
        if "electrical" in line:
            data.remove(line)

    # Finally, write the new file :
    with open(output, "w+") as f:
        f.write(f"// THIS FILE WAS AUTOGENERATED. DO NOT EDIT.\n")
        f.write(f"// ORIGINAL FILE WAS : {str(input)}\n\n")

        f.write("module ")

        for line in data:
            if len(line.strip()) > 1:
                f.write(f"{line.strip()}\n")

        f.write("endmodule\n\n")
        f.write(f"// FILE WAS CREATED ON :{datetime.datetime.now()}\n\n")

    return


def generate_json(sources: list[Path], targets: list[Path]) -> None:
    """
    This function call verilator to generate the JSON output of the module, enabling further port couting procedure.
    """
    for index, source in enumerate(sources):
        subprocess.run(
            ["verilator", "--json-only-output", f"{targets[index]}", f"{source}"],
            text=True,
        )
    return


def parse_json(
    files: list[Path],
) -> tuple[list[dataport], list[dataport], list[dataport]]:
    """
    This function count the port, and resolve their specs into the generated JSON.
    """
    # Init ports
    inputs = []
    outputs = []
    inouts = []
    modules = []

    for file in files:
        obj = None
        with open(file, "r") as f:
            obj = json.load(f)

        # Fetch module name
        name = obj["modulesp"][0]["name"]
        print(f"Found module : {name}")
        modules.append(name)

        # Fetching port types
        print("Fetching port types...")
        types_tmp = obj["miscsp"][0]["typesp"]

        types = dict()

        for type_tmp in types_tmp:
            types[type_tmp["dtypep"]] = type_tmp.get("range", "0:0")

        # Fetching ports ...
        print("Fetching ports ...")
        for port in obj["modulesp"][0]["stmtsp"]:
            if (port["type"] != "VAR") or port["direction"] == "NONE":
                continue

            print(
                f"Found port : {port['name']} : {port['direction']} ({port['dtypep']}) !"
            )
            tmp = dataport(
                f"{name}#{port['name']}",
                port["direction"],
                port["dtypep"],
                types[port["dtypep"]],
            )

            match port["direction"]:
                case "INPUT":
                    inputs.append(tmp)
                case "OUTPUT":
                    outputs.append(tmp)
                case "INOUT":
                    inouts.append(tmp)

    return inputs, outputs, inouts, modules


def match_ports(
    inputs: list[dataport], outputs: list[dataport], inouts: list[dataport]
) -> tuple[list[dataport], list[dataport], list[dataport], list[dataport]]:
    """
    This function look for duplicate net names, and transform them into wires to be shared rather than individual ports.
    """
    wires = []

    def get_wires(ports: list[dataport]) -> list[dataport]:
        t_wires = []

        # That's not really nice in terms of performance, but as they're top modules, we don't expect very long lists, the delta is acceptable.
        for port1 in ports:
            for port2 in ports:
                if port1 is port2:
                    continue

                if port1.name.split("#")[-1] == port2.name.split("#")[-1]:
                    t_wires.append(
                        dataport(
                            port1.name.split("#")[-1],
                            port1.direction,
                            port1.type,
                            port1.width,
                        )
                    )
                    # ports.remove(port2)

        return t_wires
    # end of function

    # Matching the ports
    wires.extend(get_wires(inputs))
    wires.extend(get_wires(outputs))
    wires.extend(get_wires(inouts))

    # Removing duplicates
    wires = list(set(wires))

    return inputs, outputs, inouts, wires


def generate_module(
    target: Path,
    modules: list[str],
    inputs: list[dataport],
    outputs: list[dataport],
    inouts: list[dataport],
    wires: list[dataport],
) -> None:
    """
    Generate the top level verilog file, that will be compiled into the ngspice shared library
    """

    with open(target, "w+") as f:
        # Adding some basic verilog features
        f.write(f"// THIS FILE WAS AUTOGENERATED. DO NOT EDIT.\n")

        f.write(f"module {target.stem} (\n")

        first = False

        # Generating a global net list and add them to the module
        globnet = []
        for wire in wires:
            globnet.append(wire.name)
            # Add the comma if needed : 
            if first != False:
                f.write(",")
            f.write(f"\n    {wire.direction.lower():8} [{str(wire.width).center(8)}] {wire.name.replace("#", "_")}")
            first = True

        def append_nets(netlist: list[dataport], type: str, first: bool):
            # Iterate over the nets : 
            for net in netlist:

                # Ensure the net is not global 
                if net.name.split("#")[-1] not in globnet:

                    # Add the comma if needed : 
                    if first != False:
                        f.write(",")

                    # Write the net and update the first
                    f.write(f"\n    {type:8} [{str(net.width).center(8)}] {net.name.replace("#", "_")}")
                    first = True

        # Adding unique ports :

        print(wires)
        append_nets(inouts, "inout", first)
        append_nets(inputs, "input", first)
        append_nets(outputs, "output", first)

        # Closing module init : 
        f.write("\n\n);\n\n")

        def append_module_net(netlist: list[dataport], file, module_name, first) -> bool:

            # Iterate over the nets lists : 
            for net in netlist:

                # If the net is from within this module : 
                if net.name.split("#")[0] == module_name:

                    # Append comma if needed
                    if first != False:
                        file.write(",")

                    # Write the verilog syntax to connect it
                    if net.name.split("#")[-1] in globnet: 
                        file.write(f"\n        .{str(net.name.split("#")[-1]):12}({net.name.split("#")[-1]})")
                    else:
                        file.write(f"\n        .{str(net.name.split("#")[-1]):12}({net.name.replace("#", "_")})")
                    first = True

            return first

        # Adding component instantiation now :
        for module in modules:
            f.write(f"    {module} u_{module} (")

            # Append the net names
            first = False
            first = append_module_net(inouts, f, module, first)
            first = append_module_net(inputs, f, module, first)
            first = append_module_net(outputs, f, module, first)

            f.write("\n    );\n\n")

            # Need to handle the missing pins -> mis_matched naming !

        f.write("endmodule\n\n")
        f.write(f"// FILE WAS CREATED ON :{datetime.datetime.now()}\n\n")

    return


def generate_sym():
    pass


if __name__ == "__main__":
    parser = argparse.ArgumentParser()
    parser.add_argument(
        "files",
        nargs="+",
        help="The input verilog files to be combined into a single top",
    )
    parser.add_argument(
        "-n",
        "--name",
        default="top.v",
        help="Name of the top module to be used. Default = top.v",
    )
    parser.add_argument(
        "-t",
        "--temp",
        default="/tmp/wrappergen",
        help="Path of the temporary json files. Default to /tmp/wrappengen/",
    )
    parser.add_argument(
        "-w",
        "--wire",
        default="yes",
        help="Automatically merge the wire that share a same net into a single output at the end. Default = yes.",
    )
    parser.add_argument(
        "-s",
        "--sym",
        default="yes",
        help="Generate the xschem symbol in the same pass. Default = yes",
    )
    parser.add_argument(
        "-a",
        "--analog",
        default="no",
        help="Enable the analog mode, in which the file is treated as it, and generate a symbol from it. Default to no.",
    )

    parser.description = """This tool enable the user to combine multiple verilog files into a single, higher level one.
    especially usefull when working with d_cosim in ngspice, which can only tolerate a single digital block !"""

    parser.epilog = """If you have some issues, perhaps use the -w=no / --wire=no option to disable the grouping of the same 
    net ports. With the default value, two ports that share the name "clk" would be exposed as one. This make the design simpler,
    but could lead to issues. Always start here !"""

    # Parse arguments :
    args = parser.parse_args()

    # First, ensure path are existing :
    tmp = Path(args.temp)
    tmp.mkdir(parents=True, exist_ok=True)

    # Ensure no more than one file in analog mode was passed :
    if args.analog == "yes":
        if len(args.files) > 1:
            print("In analog mode, no more than one file are handled.")
            exit(1)

    # Generate paths and files lists
    sources = [Path(t).resolve() for t in args.files]
    extracted = [Path(tmp / t.name).with_suffix(".json") for t in sources]
    top = Path(args.name).resolve()

    # If we're in analog mode : Convert the file into it's digital stub
    if args.analog == "yes":
        print("Converting the .va file into it's verilog stub ...")
        sources = sources[0]
        vlog = extracted[0].with_suffix(".v")
        va2v(sources, vlog)
        sources = [vlog]

    # Generate the JSON data and extract the data
    print("Generating JSON reports ...")
    generate_json(sources, extracted)

    print("Reading reports ...")
    inputs, outputs, inouts, modules = parse_json(extracted)

    # Optionnaly, match the ports :
    wires = []
    if args.wire == "yes":
        print("Combining ports into single ports ...")
        inputs, outputs, inouts, wires = match_ports(
            inputs, outputs, inouts
        )

    # Finally, generating the top level entity :
    if args.analog == "no":
        generate_module(
            top,
            modules,
            inputs,
            outputs,
            inouts,
            wires,
        )

    print(modules)
    print(inputs)
    print(outputs)
    print(inouts)
    print(wires)


